// node_modules/random-seedable/src/PRNG.js
var PRNG = class _PRNG {
  /**
   * @constructor
   * @param {number | bigint} max -> Max number that can be generated by this generator.
   * @param {number | bigint} seed -> Initial seed.
   */
  constructor(max, seed) {
    this.max = max;
    this._seed = seed;
  }
  /**
   * Casts the given BigInt number to an unsigned big int with the given
   * number of bits.
   *
   * @protected
   * @param {bigint} number -> A string param.
   * @param {number} bits -> An optional param (Closure syntax)
   * @return {bigint} This is the result
   */
  cast(number, bits) {
    return BigInt.asUintN(bits, number);
  }
  /**
   * Checks that a given number is within the range.
   *
   * @protected
   * @param {number} number -> A string param.
   * @throws Error -> Number greater than max.
   */
  checkNum(number) {
    if (number > this.max) {
      throw new Error(`Number greater than ${this.max}`);
    }
  }
  /**
   * Resets the PRNG.
   * To be implemented by sub-classes.
   *
   * @public
   * @throws Error -> Method not implemented.
   */
  reset() {
    if (this.constructor === _PRNG) {
      throw new Error("Method not implemented");
    }
  }
  /**
   * Private method for integer generation.
   * To be implemented by sub-classes.
   *
   * @protected
   * @return {bigint} Random integer.
   */
  _int() {
    if (this.constructor === _PRNG) {
      throw new Error("Method not implemented");
    }
    return BigInt(0);
  }
  /**
   * Generates a boolean with the formula random.float() >= 0.5
   *
   * @example
   * random.bool();
   *
   * @example
   * random.bool(); // true
   *
   * @public
   * @returns {boolean} True/False.
   */
  bool() {
    return this.float() >= 0.5;
  }
  /**
   * Generates a random boolean with probability of it being true denoted by the pTrue parameter.
   * For example, when pTrue=0.8, 80% of the numbers generated with this method will be true.
   *
   * @example
   * random.coin(pTrue);
   *
   * @example
   * random.coin(0.8); // true
   *
   * @public
   * @param {number} pTrue -> Probability of generating a true value.
   * @returns {boolean} True/False.
   */
  coin(pTrue = 0.5) {
    return this.float() < pTrue;
  }
  /**
   * Generates and returns the next number in the PRNGs sequence.
   *
   * @example
   * random.int();
   *
   * @example
   * random.int(); // 85424123
   *
   * @public
   * @returns {number} Number less than 2 ** 32 for 32 bit generators.
   */
  int() {
    return Number(this._int());
  }
  /**
   * Generates and returns the next number in the PRNGs sequence and returns it as a Bigint.
   *
   * @example
   * random.bigInt();
   *
   * @example
   * random.bigInt(); // 85424123n
   *
   * @public
   * @returns {bigint} Number less than 2 ** 32 for 32 bit generators represented as a BigInt class.
   */
  bigInt() {
    return this._int();
  }
  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float();
   *
   * @example
   * random.float(); // 0.234242
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float() {
    return this.int() * (1 / this.max);
  }
  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float53();
   *
   * @example
   * random.float53(); // 0.2342422341231
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float53() {
    const a = this.int() >>> 5;
    const b = this.int() >>> 6;
    return (a * 67108864 + b) * (1 / 9007199254740992);
  }
  /**
   * Generates a number within the given range.
   *
   * @example
   * random.randRange(min, max);
   *
   * @example
   * const lowerBound = 4;
   * const upperBound = 2432;
   * random.randRange(lowerBound, upperBound); // 36.
   *
   * @public
   * @param {number} min -> Lower bound of the numbers to generate (inclusive).
   * @param {number} max -> Upper bound of the numbers to generate (inclusive).
   * @returns {number} Number min <= Number <= max.
   */
  randRange(min, max) {
    const range = max - min;
    const t = this.max % range;
    let r = this.int();
    while (r < t) {
      r = this.int();
    }
    return min + r % range;
  }
  /**
   * Generates a number below the given maximum.
   *
   * @example
   * random.randBelow(max);
   *
   * @example
   * const upperBound = 2432;
   * random.randBelow(upperBound);  // 285.
   *
   * @public
   * @param {number} max -> Upper bound of the numbers to generate (inclusive).
   * @returns {number} Number <= max
   */
  randBelow(max) {
    return this.randRange(0, max);
  }
  /**
   * Picks a random element from the array.
   *
   * @example
   * random.choice(array)
   *
   * @example
   * const arr = [1, 4, 2, 3];
   * random.choice(arr); // 4
   *
   * @public
   * @param {any[]} array -> Array of any type from which we randomly select one item.
   * @returns {any} A single item from the array of type ?.
   */
  choice(array) {
    return array[this.randBelow(array.length)];
  }
  /**
   * Randomly shuffles the given array using the fisher-yates algorithm.
   *
   * @example
   * random.shuffle(array, inPlace = false)
   *
   * @example
   * const arr = [1, 4, 2, 3];
   * const shuffled = random.shuffle(arr, false);
   * console.log(arr); // [1, 4, 2, 3]
   * console.log(shuffled); // [4, 2, 3, 1]
   *
   * @example
   * const arr = [1, 4, 2, 3];
   * const shuffled = random.shuffle(arr, true);
   * console.log(arr); // [4, 2, 3, 1]
   * console.log(shuffled); // [4, 2, 3, 1]
   *
   * @public
   * @param {any[]} array -> Array of any type to be shuffled.
   * @param {boolean} inPlace -> Shuffle the array (true) or shuffle a copy of array (false).
   * @returns {any[]} Array shuffled (inPlace === false), shuffled copy of array (inPlace === true).
   */
  shuffle(array, inPlace = true) {
    let toSort = array;
    if (!inPlace) {
      toSort = Array.from(toSort);
    }
    for (let i = toSort.length - 1; i > 0; i--) {
      const j = this.randRange(0, i);
      const temp = toSort[i];
      toSort[i] = toSort[j];
      toSort[j] = temp;
    }
    return toSort;
  }
  /**
   * Creates an array of the given size populated with the result of the mapFn.
   *
   * @protected
   * @param {number} size -> Length of the array to create.
   * @param {function(): boolean | number | bigint} mapFn -> Function which we use to fill array.
   * @returns {boolean[] | number[] | bigint[]} Array created by repeated calls to the mapFn.
   */
  initArray(size, mapFn) {
    return Array.from({ length: size }, mapFn);
  }
  /**
   * Generates an n size array populated with booleans.
   *
   * @example
   * random.boolArray(size);
   *
   * @example
   * const size = 256;
   * random.boolArray(size);
   *
   * @public
   * @param {number} size -> Size of the array to generate.
   * @returns {boolean[]} Array[Boolean] of length size.
   */
  boolArray(size) {
    return this.initArray(size, () => this.bool());
  }
  /**
   * Generates an n size array of random booleans with probability of it being true
   * denoted by the pTrue parameter. For example, when pTrue=0.8, 80% of the numbers
   * in the generated array will be true.
   *
   * @example
   * random.coinArray(size, pTrue);
   *
   * @example
   * const size = 256;
   * const pTrue = 0.8;
   * random.coinArray(size, pTrue);
   *
   * @public
   * @param {number} size -> Size of the array to generate.
   * @param {number} pTrue -> Probability of generating a true value.
   * @returns {boolean[]} Array[Boolean] of length size.
   */
  coinArray(size, pTrue = 0.5) {
    return this.initArray(size, () => this.coin(pTrue));
  }
  /**
   * Generates an n size array populated with integers.
   *
   * @example
   * random.intArray(size);
   *
   * @example
   * const size = 256;
   * random.intArray(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {number[]} Array[Number] of length size.
   */
  intArray(size) {
    return this.initArray(size, () => this.int());
  }
  /**
   * Generates an n size array populated with Big Integers.
   *
   * @example
   * random.bigIntArray(size);
   *
   * @example
   * const size = 256;
   * random.bigIntArray(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {bigint[]} Array[BigInt] of length size.
   */
  bigIntArray(size) {
    return this.initArray(size, () => this.bigInt());
  }
  /**
   * Generates an n size array populated within the given range.
   *
   * @example
   * random.randRangeArray(size, min, max);
   *
   * @example
   * const size = 256;
   * const lowerBound = 4;
   * const upperBound = 2432;
   * random.randRangeArray(size, lowerBound, upperBound);
   *
   * @public
   * @param {number} size -> Size of the array to generate.
   * @param {number} min -> Lower bound of the numbers to generate (inclusive).
   * @param {number} max -> Upper bound of the numbers to generate (inclusive).
   * @returns {number[]} Array[Number] of length size filled w/ min <= num <= max.
   */
  randRangeArray(size, min, max) {
    return this.initArray(size, () => this.randRange(min, max));
  }
  /**
   * Generates an n size array populated with floats.
   *
   * @example
   * random.floatArray(size);
   *
   * @example
   * const size = 256;
   * random.floatArray(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {number[]} Array[Number] between 0.0 - 1.0 of length size.
   */
  floatArray(size) {
    return this.initArray(size, () => this.float());
  }
  /**
   * Generates an n size array populated with floats.
   *
   * @example
   * random.float53Array(size);
   *
   * @example
   * const size = 256;
   * random.float53Array(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {number[]} Array[Number] between 0.0 - 1.0 of length size.
   */
  float53Array(size) {
    return this.initArray(size, () => this.float53());
  }
};
var PRNG_default = PRNG;

// node_modules/random-seedable/src/PRNG64.js
var PRNG64 = class extends PRNG_default {
  /**
   * @constructor
   * @param {number | bigint} max -> Max number that can be generated by this generator.
   * @param {number | bigint} seed -> Initial seed.
   */
  constructor(max, seed) {
    super(max, seed);
  }
  /**
   * Generates and returns the next number in the PRNGs sequence.
   * As this is a 64 bit generator and javascript integers are limited to 53 bits,
   * the generated BigInt result is right-shifted 11 bits; discarding the least significant bits.
   *
   * @example
   * random.int();
   *
   * @example
   * random.int(); // 85424123
   *
   * @public
   * @returns {number} Number less than 2 ** 53 for 64 bit generators.
   */
  int() {
    return Number(this._int() >> 11n);
  }
  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float();
   *
   * @example
   * random.float(); // 0.234242
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float() {
    return this.int() / this.max;
  }
  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float53();
   *
   * @example
   * random.float53(); // 0.2342422341231
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float53() {
    return this.float();
  }
};
var PRNG64_default = PRNG64;

// node_modules/random-seedable/src/constants.js
var MAX32 = 2 ** 32;
var MAX53 = 2 ** 53;
var MAX64 = 2n ** 64n;

// node_modules/random-seedable/src/xorshift64.js
var XORShift64 = class extends PRNG64_default {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} a -> First bit shift parameter.
   * @param {number | bigint} b -> Second bit shift parameter.
   * @param {number | bigint} c -> Third bit shift parameter.
   */
  constructor(seed = Date.now(), a = 13, b = 7, c = 17) {
    super(MAX53, BigInt(seed));
    this.seed = seed;
    this.a = this.cast(BigInt(a), 64);
    this.b = this.cast(BigInt(b), 64);
    this.c = this.cast(BigInt(c), 64);
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 64);
    this.x = this._seed;
  }
  _int() {
    let { x } = this;
    x ^= x << this.a;
    x = this.cast(x, 64);
    x ^= x >> this.b;
    x ^= x << this.c;
    x = this.cast(x, 64);
    this.x = x;
    return x;
  }
};
var xorshift64_default = XORShift64;

// node_modules/random-seedable/src/lcg.js
var LCG = class extends PRNG_default {
  /**
   * @constructor
   * @param {number} seed ->  Initial seed.
   * @param {number} a -> Multiplier parameter.
   * @param {number} c -> Increment parameter.
   * @param {number} m -> Modulus parameter.
   */
  constructor(seed = Date.now(), a = 1664525, c = 1013904223, m = 4294967296) {
    super(m, seed);
    [seed, a, c, m].forEach((num) => this.checkNum(num));
    this.seed = seed;
    Object.assign(this, { a, c, m });
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = seed;
    this.x = this._seed;
  }
  _int() {
    this.x = (this.a * this.x + this.c) % this.m;
    return BigInt(this.x);
  }
};
var lcg_default = LCG;

// node_modules/random-seedable/src/pcg.js
var PCG = class extends PRNG_default {
  // constructor(seed = 0x4d595df4d0f33173n, mul = 6364136223846793005n, inc = 1442695040888963407n) {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} mul -> Multiplier parameter.
   * @param {number | bigint} inc -> Increment parameter.
   */
  constructor(seed = Date.now(), mul = 6364136223846793005n, inc = 1442695040888963407n) {
    super(MAX32, BigInt(seed));
    this.seed = seed;
    this.mul = this.cast(BigInt(mul), 64);
    this.inc = this.cast(BigInt(inc), 64);
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + sets.
   *
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 64);
    this.x = this._seed;
  }
  /**
   * 32 bit rotation op.
   * @param {bigint} x -> x parameter of PCG algorithm.
   * @param {bigint} r -> r parameter of PCG algorithm.
   * @returns {bigint} Returns 32 bit result of rotation operation.
   */
  rotr32(x, r) {
    return this.cast(x >> r | x << (-r & 31n), 32);
  }
  _int() {
    let x = this.x;
    let count = x >> 59n;
    this.x = x * this.mul + this.inc;
    this.x = this.cast(this.x, 64);
    x ^= x >> 18n;
    return this.rotr32(this.cast(x >> 27n, 32), count);
  }
};
var pcg_default = PCG;

// node_modules/random-seedable/src/mersenneTwister.js
var MATRIX_A = 0x9908b0dfn;
var UPPER_MASK = 0x80000000n;
var LOWER_MASK = 0x7fffffffn;
var MersenneTwister = class extends PRNG_default {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} n -> Degree of recurrence.
   * @param {number | bigint} m -> Middle word, offset used during recurrence.
   */
  constructor(seed = Date.now(), n = 624, m = 397) {
    super(MAX32, BigInt(seed));
    this.state = new Array(n);
    this.N = n;
    this.M = m;
    this.initf = 0;
    this.stateIndex = 0;
    this.seed = seed;
  }
  /**
   * Resets the generator to its original state.
   *
   * @public
   */
  reset() {
    this.seed = this._seed;
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 32);
    this.state[0] = this._seed & 0xffffffffn;
    for (let j = 1; j < this.N; j++) {
      this.state[j] = 1812433253n * (this.state[j - 1] ^ this.state[j - 1] >> 30n) + BigInt(j);
      this.state[j] &= 0xffffffffn;
    }
    this.initf = 1;
  }
  /**
   * @private
   * @param {bigint} u
   * @param {bigint} v
   * @returns {bigint}
   */
  mixBits(u, v) {
    return u & UPPER_MASK | v & LOWER_MASK;
  }
  /**
   * Computes the twist function.
   * @private
   * @param {bigint} u
   * @param {bigint} v
   * @returns {bigint}
   */
  twist(u, v) {
    return this.mixBits(u, v) >> 1n ^ (v & 1n ? MATRIX_A : 0n);
  }
  /**
   * Computes the next state of the generator.
   * @private
   */
  nextState() {
    let j = 0;
    for (; j < this.N - this.M; j++) {
      this.state[j] = this.state[j + this.M] ^ this.twist(this.state[j], this.state[j + 1]);
    }
    for (; j < this.N - 1; j++) {
      this.state[j] = this.state[j + (this.M - this.N)] ^ this.twist(this.state[j], this.state[j + 1]);
    }
    this.state[this.N - 1] = this.state[this.M - 1] ^ this.twist(this.state[this.N - 1], this.state[0]);
    this.stateIndex = 0;
    this.initf = 0;
  }
  _int() {
    let y;
    if (this.stateIndex >= this.N || this.initf) {
      this.nextState();
    }
    y = this.state[this.stateIndex++];
    y ^= y >> 11n;
    y ^= y << 7n & 0x9d2c5680n;
    y ^= y << 15n & 0xefc60000n;
    y ^= y >> 18n;
    return y;
  }
};
var mersenneTwister_default = MersenneTwister;

// node_modules/random-seedable/src/xorshift.js
var XORShift = class extends PRNG_default {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} a -> First bit shift parameter.
   * @param {number | bigint} b -> Second bit shift parameter.
   * @param {number | bigint} c -> Third bit shift parameter.
   */
  constructor(seed = Date.now(), a = 13, b = 17, c = 5) {
    super(MAX32, BigInt(seed));
    this.seed = seed;
    this.a = this.cast(BigInt(a), 32);
    this.b = this.cast(BigInt(b), 32);
    this.c = this.cast(BigInt(c), 32);
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 32);
    this.x = this._seed;
  }
  _int() {
    let { x } = this;
    x ^= x << this.a;
    x = this.cast(x, 32);
    x ^= x >> this.b;
    x ^= x << this.c;
    x = this.cast(x, 32);
    this.x = x;
    return x;
  }
};
var xorshift_default = XORShift;

// node_modules/random-seedable/src/xorshift128.js
var XORShift128 = class extends PRNG_default {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} y -> First bit shift parameter.
   * @param {number | bigint} z -> Second bit shift parameter.
   * @param {number | bigint} w -> Third bit shift parameter.
   */
  constructor(seed = Date.now(), y = 362436069, z = 521288629, w = 88675123) {
    super(MAX32, BigInt(seed));
    this.seed = seed;
    this.y = this.cast(BigInt(y), 32);
    this.z = this.cast(BigInt(z), 32);
    this.w = this.cast(BigInt(w), 32);
    this.origParams = {
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
    Object.assign(this, this.origParams);
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 32);
    this.reset();
  }
  _int() {
    let { x, w } = this;
    x ^= x << 11n;
    x = this.cast(x, 32);
    x ^= x >> 8n;
    w ^= w >> 19n;
    this.x = this.y;
    this.y = this.z;
    this.z = this.w;
    this.w = w ^ x;
    return this.w;
  }
};
var xorshift128_default = XORShift128;

// node_modules/random-seedable/src/xorshift128Plus.js
var XORShift128Plus = class extends PRNG64_default {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} y -> Second seed.
   */
  constructor(seed = Date.now(), y = 362436069) {
    super(MAX53, seed);
    this.seed = seed;
    this.y = this.cast(BigInt(y), 64);
    this.origParams = { y: this.y };
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
    Object.assign(this, this.origParams);
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 64);
    this.reset();
  }
  _int() {
    let s1 = this.x;
    const s0 = this.y;
    const result = this.cast(s0 + s1, 64);
    this.x = s0;
    s1 ^= s1 << 23n;
    s1 = this.cast(s1, 64);
    this.y = s1 ^ s0 ^ s1 >> 18n ^ s0 >> 5n;
    return result;
  }
};
var xorshift128Plus_default = XORShift128Plus;

// node_modules/random-seedable/src/xorwow.js
var XORWow = class extends PRNG_default {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} y -> First state initial value.
   * @param {number | bigint} z -> Second state initial value.
   * @param {number | bigint} w -> Third state initial value.
   * @param {number | bigint} v -> Fourth state initial value.
   * @param {number | bigint} d -> Fifth state initial value.
   * @param {number | bigint} weyl -> Additive counter.
   */
  constructor(seed = Date.now(), y = 362436069, z = 521288629, w = 88675123, v = 5783321, d = 6615241, weyl = 362437) {
    super(MAX32, BigInt(seed));
    this._seed = this.cast(this._seed, 32);
    this.x = this._seed;
    this.y = this.cast(BigInt(y), 32);
    this.z = this.cast(BigInt(z), 32);
    this.w = this.cast(BigInt(w), 32);
    this.v = this.cast(BigInt(v), 32);
    this.d = this.cast(BigInt(d), 32);
    this.weyl = this.cast(BigInt(weyl), 32);
    this.origParams = {
      y: this.y,
      z: this.z,
      w: this.w,
      v: this.v,
      d: this.d
    };
  }
  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
    Object.assign(this, this.origParams);
  }
  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }
  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 32);
    this.reset();
  }
  _int() {
    let t = this.x;
    let { v } = this;
    t ^= t >> 2n;
    t ^= t << 1n;
    v ^= v << 4n;
    this.x = this.y;
    this.y = this.z;
    this.z = this.w;
    this.w = this.v;
    this.v = this.cast(v ^ t, 32);
    this.d += this.weyl;
    return this.cast(this.d + this.v, 32);
  }
};
var xorwow_default = XORWow;

// node_modules/random-seedable/src/index.js
var random = new xorshift64_default(Date.now());
var src_default = new xorshift64_default(Date.now());
export {
  lcg_default as LCG,
  mersenneTwister_default as MersenneTwister,
  pcg_default as PCG,
  xorshift_default as XORShift,
  xorshift128_default as XORShift128,
  xorshift128Plus_default as XORShift128Plus,
  xorshift64_default as XORShift64,
  xorwow_default as XORWow,
  src_default as default,
  random
};
//# sourceMappingURL=random-seedable.js.map
